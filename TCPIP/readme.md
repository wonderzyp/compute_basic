
TCP实现简易回声客户端
---
### 服务端
1. 创建套接字
2. 初始化地址结构体`sockaddr_in`(IP地址可INADDR_ANY)
3. 调用`bind()`将结构体信息绑定至套接字
4. 监听`listen()`
5. 使用`accept()`返回新的`socket`，建立连接通信.

### 客户端
1. 创建套接字
2. 初始化`sockaddr_in`
3. `connect()`请求连接指定的IP地址

UDP实现发送数据
---
UDP不严格区分客户端与服务端;
UDP**数据收发存在边界**，一次发送对应一次接收
> TCP数据收发不存在边界，当字符串过长时可能分成多次传输，导致客户端调用`read`时字符串尚未完全传输完毕。
> 为解决此问题，可在应用层定义传输协议：例如检查接收到的数据长度

半关闭
---
当两台主机建立套接字连接以后，每个主机拥有单独的输入输出流。
`close()`函数意味着完全断开两个流，同时失去发送和接受数据的功能；
`shutdown()`可实现单方面关闭某一流的功能

仅关闭TCP输入、输出流中的一个，保持另一个的开放状态
如此，服务端在传输完毕后，依旧可以接受客户端的反馈等信息

多进程
---
#### 僵尸进程
僵尸进程：Linux下，子进程main函数return后不会消失，可通过以下几种方式销毁：
1. wait: 一直阻塞直到有子进程终止，wait将返回值保存至status内
2. waitpid：类似自旋锁，不会阻塞
3. 信号：SIGALRM, SIGINT, SIGHLD(子进程终止信号)

父进程可借助status获取子进程的返回值
