
TCP实现简易回声客户端
---
### 服务端
1. 创建套接字
2. 初始化地址结构体`sockaddr_in`(IP地址可INADDR_ANY)
3. 调用`bind()`将结构体信息绑定至套接字
4. 监听`listen()`
5. 使用`accept()`返回新的`socket`，建立连接通信.

### 客户端
1. 创建套接字
2. 初始化`sockaddr_in`
3. `connect()`请求连接指定的IP地址

UDP实现发送数据
---
UDP不严格区分客户端与服务端;
UDP**数据收发存在边界**，一次发送对应一次接收
> TCP数据收发不存在边界，当字符串过长时可能分成多次传输，导致客户端调用`read`时字符串尚未完全传输完毕。
> 为解决此问题，可在应用层定义传输协议：例如检查接收到的数据长度

半关闭
---
当两台主机建立套接字连接以后，每个主机拥有单独的输入输出流。
`close()`函数意味着完全断开两个流，同时失去发送和接受数据的功能；
`shutdown()`可实现单方面关闭某一流的功能

仅关闭TCP输入、输出流中的一个，保持另一个的开放状态
如此，服务端在传输完毕后，依旧可以接受客户端的反馈等信息


多进程客户端
---
#### 基本思路
当监听到连接时借助`fork()`产生子进程，每个连接上的客户端由专门的进程负责处理数据。
细节：
1. 连接成功后，子进程关闭监听fd，父进程关闭accept产生的fd
2. 借助signation处理僵尸进程

#### 僵尸进程
僵尸进程：Linux下，子进程main函数return后不会消失，可通过以下几种方式销毁：
1. wait: 一直阻塞直到有子进程终止，wait将返回值保存至status内
2. waitpid：不会阻塞，传递`WNOHANG`后，没有终止的子进程则返回0并退出函数
3. 信号：SIGALRM, SIGINT, SIGHLD(子进程终止信号)
父进程可借助status获取子进程的返回值

#### 信号处理僵尸进程
依据：子进程终止时产生`SIGCHLD`信号
配合`waitpid`使用

IO复用客户端
---
#### select
借助`select`注册想要检测的fd，当监测事件发生后，对应文件集会被置为0(除监视对象外)
每次需遍历监视文件集内所有fd，寻找仍为1的fd

性能瓶颈：每次调用`select`需向内核传递监视对象的信息
#### epoll
`select`声明`fd_set`变量保存监视对象文件描述符
`epoll`由操作系统直接监视文件描述符
通过结构体`epoll_event`将发生变化的文件描述符集中在一起
**使用步骤：**
1. `epoll_create`创建fd保存空间
2. `epoll_ctl`注册监视fd与事件
3. `epoll_wait`等待发生对应事件，返回发生事件的fd数量
> epoll_wait直接将所有发生变化的fd集合写入第二个传入参数指定地址，无需遍历


